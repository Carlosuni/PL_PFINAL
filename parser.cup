/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.pFinal;

import java_cup.runtime.*;
import cup.pFinal.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.util.Hashtable;
import java.util.List;


/* Custom Imports */
import java.lang.Math; 


parser code {:
  protected Lexer lexer;
  Hashtable<String, Object> varTable = new Hashtable<String, Object>();
  Hashtable<String, List> structTable = new Hashtable<String, List>();
:}


/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIVIDEDBY, LPAREN, RPAREN;
terminal            AND, OR, NOT, EQUALTO, LEQUAL, GEQUAL, LTHAN, GTHAN;
terminal String 	INTTYPE, REALTYPE, BOOLEANTYPE, STRUCTTYPE, CHARTYPE;
terminal            LBRACE, RBRACE, DOT, COMMA, ASSIGNSYMBOL;
terminal          	SI, ENTONCES, SINO, FINSI, MIENTRAS, FINMIENTRAS;
terminal          	FUNCION, RETURN;
terminal Integer    NUMBER;        // our scanner provides numbers as integers

terminal String    	COMMENT;
terminal Double    	DOUBLENUMBER;
terminal Integer    HEXNUMBER;
terminal String		ID;
terminal String		CHARACTER;
terminal Boolean	BOOLEANVALUE;

/* Non terminals */
non terminal 			programa;
non terminal            blq_sentencias;
non terminal            sentencia;
non terminal           	sent_decl;
non terminal 			sent_uso;
non terminal 			sent_flujo;
non terminal 			decl_variable;
non terminal 			asignacion;
non terminal Double		expresion;
non terminal 			condicional;
non terminal			bucle;
non terminal Double		operando;
non terminal 			key_tipo;
non terminal 			decl_struct;
non terminal 			lista_decl;
non terminal 			def_funcion;
non terminal 			arg;
non terminal 			lista_args;
non terminal 			uso_funcion;
non terminal 			lista_expresiones;
non terminal Boolean	operando_cond;
non terminal Boolean	term_cond;
non terminal Boolean	expresion_cond;
non terminal Double    term;      // used to store evaluated subexpressions


/* The grammar rules */
programa ::= blq_sentencias {:  :}
          ;
            	 
blq_sentencias ::= blq_sentencias sentencia 	{:  :}
           		 | sentencia                   	{:  :}
            	 ;

sentencia ::= sent_decl			{:  :}
			| sent_uso				{:  :}
			| sent_flujo				{:  :}
			| LBRACE blq_sentencias RBRACE 				{:  :}
            | COMMENT	                    {:  												:}			
            | uso_funcion	                    {:  												:}			
            | def_funcion	                    {:  												:}			
            | asignacion	                    {:  												:}			
			;
			
sent_decl ::= decl_variable SEMI			{:  :}
			| decl_struct SEMI			{:  :}
			;
			
sent_uso ::= asignacion SEMI			{:  :}
		   | expresion:e SEMI				{: System.out.println(e); :}
			;			

sent_flujo ::= condicional			{:  :}
		   | bucle				{:  :}	
		   ;		
		   
operando    ::= NUMBER:n	               		{: RESULT = Double.valueOf(n);       				:}
              | DOUBLENUMBER:n	            {: RESULT = n;       								:}
              | HEXNUMBER:n	                {: RESULT = Double.valueOf(n);       				:}     
			  | LPAREN expresion:e RPAREN	        {: RESULT = e;           							:}
              //| MINUS operando:e                {: RESULT = -e;           							:}           
              //| PLUS operando:e                 {: RESULT = e;           							:}
              | ID:e 			                {:   Double value = (Double) varTable.get(e);
												     if (value == null) {
													   parser.report_error("Error: Undeclared Identifier " + e, new Symbol(sym.ID, e));
													   value = new Double(0.0);
													 }
													 RESULT = value; 	      							:}           		
             // | ID:e1 DOT ID:e2 			        {: RESULT = e1;          							:}           		
			  ;	   

condicional ::= SI expresion_cond ENTONCES blq_sentencias FINSI	 {:  :}
              | SI expresion_cond ENTONCES blq_sentencias SINO blq_sentencias FINSI 	 {:  :}
              ;	

bucle ::= MIENTRAS expresion blq_sentencias FINMIENTRAS	 {:  :}
        ;	

key_tipo ::= INTTYPE:e	 {: RESULT = String.valueOf(e); :}
		   | REALTYPE:e	 {: RESULT = String.valueOf(e); :}
		   | BOOLEANTYPE:e	 {: RESULT = String.valueOf(e); :}
		   | CHARTYPE:e	 {: RESULT = String.valueOf(e); :}
		   ;

decl_variable ::= key_tipo:k ID:i ASSIGNSYMBOL expresion:e	 {: varTable.put(i , e);
																	System.out.println(k + " " + i + " := " + e + ";"); :}
		   		| key_tipo:k ID:i	 {: 		switch (String.valueOf(k)) {
													case "ENTERO": {
														varTable.put(i , new Double(0.0));
														break;}
													case "REAL": {
														varTable.put(i , new Double(0.0));
														break;}
													case "BOOLEANO": {
														varTable.put(i , new Boolean(false));
														break;}
													case "CARACTER": {
														varTable.put(i , Character.valueOf('a'));
														break;}		
													default: {
														System.out.println("Error: Invalid type " + k + " for variable " + i); }
										 				  //parser.report_error("Error: Undeclared Identifier " + i, new Symbol(sym.ID, e));
												}
											System.out.println(k + " " + i + ";"); 
											RESULT = String.valueOf(k); 								:}
		   		| decl_variable:k COMMA ID:i	 {: switch (String.valueOf(k)) {
													case "ENTERO": {
														varTable.put(i , new Double(0.0));
														break;}
													case "REAL": {
														varTable.put(i , new Double(0.0));
														break;}
													case "BOOLEANO": {
														varTable.put(i , new Boolean(false));
														break;}
													case "CARACTER": {
														varTable.put(i , Character.valueOf('a'));
														break;}		
													default: {
														System.out.println("Error: Invalid type " + k + " for variable " + i); }
										 				  //parser.report_error("Error: Undeclared Identifier " + i, new Symbol(sym.ID, e));
												}
											System.out.println(k + " " + i + ";"); :}											
		   		| ID:i1 ID:i2 		 {: varTable.put(i2 , new Double(0.0));
											System.out.println(i1 + " " + i2 + ";"); :}
				;		   

decl_struct ::= STRUCTTYPE ID LBRACE lista_decl RBRACE	 {:  :}
				;	
						   
lista_decl ::= lista_decl SEMI decl_variable	 {:  :}
		   	 | decl_variable	 {:  :}
			 ;

asignacion ::= ID:i ASSIGNSYMBOL expresion:e SEMI	 {: if (varTable.get(i) != null) {
														  varTable.put(i , e);
														  System.out.println(i + " := " + e + ";");
														} else {
														  parser.report_error("Error: Undeclared Identifier " + i, new Symbol(sym.ID, e));
                                                        } :}
		   	 | ID DOT ID ASSIGNSYMBOL expresion SEMI	 {:  :}
		   	 | ID ASSIGNSYMBOL CHARACTER SEMI	 {:  :}
		   	 | ID DOT ID ASSIGNSYMBOL CHARACTER SEMI	 {:  :}
			 ;		

def_funcion ::= FUNCION ID LPAREN lista_args RPAREN RETURN key_tipo LBRACE blq_sentencias RBRACE {:  :}
			  | FUNCION ID LPAREN lista_args RPAREN RETURN ID LBRACE blq_sentencias RBRACE {:  :}
			  ;	
			 
arg ::= key_tipo  ID {:  :}
	  ;	
	  						 	 
lista_args ::= {:  :}
		   	 | arg					 {:  :}
		   	 | arg COMMA lista_args					 {:  :}
			 ;

uso_funcion ::= ID LBRACE lista_expresiones RBRACE 		{:  :}
		   	  ;			

lista_expresiones ::= lista_expresiones COMMA expresion  			{:  :}
		   	 		| expresion:e					 {: RESULT = e; :}
			 		;					  	
 
term ::= term:e1 TIMES operando:e2         {: RESULT = e1 * e2;        						:}
       | term:e1 DIVIDEDBY operando:e2     {: RESULT = e1 / e2;        						:}
       | operando:e					       {: RESULT = e;        							:}
	   ;            
         			         
expresion ::= expresion:e1 PLUS  term:e2         		 {: RESULT = e1 + e2;        						:}
           	| expresion:e1 MINUS term:e2         		 {: RESULT = e1 - e2;        						:}
	     	| term:e					  				 {: RESULT = e;        								:}	
			;		
			
operando_cond ::= BOOLEANVALUE:e	               		 {: RESULT = e; 				:}
			    | LPAREN expresion_cond:e RPAREN	     {: RESULT = e;           							:}       		
			    | expresion:e1 GEQUAL expresion:e2       {: RESULT = e1 >= e2;        						:}
    	        | expresion:e1 LEQUAL expresion:e2       {:   RESULT = e1 <= e2;			:}
         	    | expresion:e1 EQUALTO expresion:e2      {:    RESULT = e1 == e2;	:}
     	        | expresion:e1 LTHAN expresion:e2        {:    RESULT = e1 < e2;		:}
    	        | expresion:e1 GTHAN expresion:e2        {:    RESULT = e1 > e2;			:}
    	    	;	   
    	    	  
term_cond ::= term_cond:e1 AND operando_cond:e2         	{:     RESULT = e1 && e2;   						:}
    	    | term_cond:e1 OR operando_cond:e2        		{:    RESULT = e1 || e2;		:}         
			; 
			
expresion_cond ::= term_cond:e					    		{: RESULT = e;        								:}	
				 | NOT term_cond:e					    	{: RESULT = !e;        								:}	
			 	 ;			 		      	    	  			
       