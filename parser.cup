/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.pFinal;

import java_cup.runtime.*;
import cup.pFinal.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.util.Hashtable;

/* Custom Imports */
import java.lang.Math; 


parser code {:
  protected Lexer lexer;
  Hashtable varTable = new Hashtable();
  Hashtable structTable = new Hashtable();
:}


/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIVIDEDBY, LPAREN, RPAREN;
terminal            AND, OR, NOT, EQUALTO, LEQUAL, GEQUAL, LTHAN, GTHAN;
terminal            INTTYPE, REALTYPE, BOOLEANTYPE, STRUCTTYPE, CHARTYPE;
terminal            LBRACE, RBRACE, DOT, COMMA, ASSIGNSYMBOL;
terminal          	SI, ENTONCES, SINO, FINSI, MIENTRAS, FINMIENTRAS;
terminal          	FUNCION, RETURN;
terminal Integer    NUMBER;        // our scanner provides numbers as integers

terminal String    	COMMENT;
terminal Double    	DOUBLENUMBER;
terminal Integer    HEXNUMBER;
terminal String		ID;
terminal String		CHARACTER;
terminal Boolean	BOOLEANVALUE;

/* Non terminals */
non terminal 			programa;
non terminal            blq_sentencias;
non terminal            sentencia;
non terminal           	sent_decl;
non terminal 			sent_uso;
non terminal 			sent_flujo;
non terminal 			decl_variable;
non terminal 			asignacion;
non terminal Double		expresion;
non terminal 			condicional;
non terminal			bucle;
non terminal Double		operando;
non terminal 			key_tipo;
non terminal 			decl_struct;
non terminal 			lista_decl;
non terminal 			def_funcion;
non terminal 			arg;
non terminal 			lista_args;
non terminal 			uso_funcion;
non terminal 			lista_expresiones;
non terminal Boolean	operando_cond;
non terminal Boolean	term_cond;
non terminal Boolean	expresion_cond;
//non terminal 			lista_cond_expresion;
//non terminal Double    expr;      // used to store evaluated subexpressions
non terminal Double    term;      // used to store evaluated subexpressions
//non terminal Double    factor;      // used to store evaluated subexpressions


/* The grammar rules */
programa ::= blq_sentencias {:  :}
          ;
            	 
blq_sentencias ::= blq_sentencias sentencia 	{:  :}
           		 | sentencia                   	{:  :}
            	 ;

sentencia ::= sent_decl			{:  :}
			| sent_uso				{:  :}
			| sent_flujo				{:  :}
			| LBRACE blq_sentencias RBRACE 				{:  :}
            | COMMENT	                    {:  												:}			
            | uso_funcion	                    {:  												:}			
            | def_funcion	                    {:  												:}			
			;
			
sent_decl ::= decl_variable			{:  :}
			| decl_struct			{:  :}
			;
			
sent_uso ::= asignacion SEMI			{:  :}
		   | expresion SEMI				{:  :}
			;			

sent_flujo ::= condicional			{:  :}
		   | bucle				{:  :}	
		   ;		
		   
operando    ::= NUMBER:n	               		{: RESULT = Double.valueOf(n);       				:}
              | DOUBLENUMBER:n	            {: RESULT = n;       								:}
              | HEXNUMBER:n	                {: RESULT = Double.valueOf(n);       				:}     
			  | LPAREN expresion:e RPAREN	        {: RESULT = e;           							:}
              //| MINUS operando:e                {: RESULT = -e;           							:}           
              //| PLUS operando:e                 {: RESULT = e;           							:}
              | ID:e 			                {:   Double value = (Double) varTable.get(e);
												     if (value == null) {
													   parser.report_error("Undeclared Identifier " + e, new Symbol(sym.ID, e));
													   value = new Double(0.0);
													 }
													 RESULT = value; 	      							:}           		
             // | ID:e1 DOT ID:e2 			        {: RESULT = e1;          							:}           		
			  ;	   

condicional ::= SI expresion_cond ENTONCES blq_sentencias FINSI	 {:  :}
              | SI expresion_cond ENTONCES blq_sentencias SINO blq_sentencias FINSI 	 {:  :}
              ;	

bucle ::= MIENTRAS expresion blq_sentencias FINMIENTRAS	 {:  :}
        ;	

key_tipo ::= INTTYPE	 {:  :}
		   | REALTYPE	 {:  :}
		   | BOOLEANTYPE	 {: :}
		   | CHARTYPE	 {:   :}
		   ;

decl_variable ::= key_tipo:k ID:i ASSIGNSYMBOL expresion:e SEMI	 {: varTable.put(i , e); :}
		   		| key_tipo ID:i SEMI	 {: varTable.put(i , null); :}
		   		| ID:i1 ID:i2 SEMI 		 {: varTable.put(i2 , null); :}
				;		   

decl_struct ::= STRUCTTYPE ID LBRACE lista_decl RBRACE SEMI	 {:  :}
				;	
						   
lista_decl ::= decl_variable lista_decl	 {:  :}
		   	 | decl_variable	 {:  :}
			 ;

asignacion ::= ID ASSIGNSYMBOL expresion SEMI	 {:  :}
		   	 | ID DOT ID ASSIGNSYMBOL expresion SEMI	 {:  :}
		   	 | ID ASSIGNSYMBOL CHARACTER SEMI	 {:  :}
		   	 | ID DOT ID ASSIGNSYMBOL CHARACTER SEMI	 {:  :}
			 ;		

def_funcion ::= FUNCION ID LPAREN lista_args RPAREN RETURN key_tipo LBRACE blq_sentencias RBRACE {:  :}
			  | FUNCION ID LPAREN lista_args RPAREN RETURN ID LBRACE blq_sentencias RBRACE {:  :}
		   	  | ID DOT ID ASSIGNSYMBOL expresion SEMI	 {:  :}
			  ;	
			 
arg ::= key_tipo  ID {:  :}
	  ;	
	  						 	 
lista_args ::= {:  :}
		   	 | arg					 {:  :}
		   	 | arg COMMA lista_args					 {:  :}
			 ;

uso_funcion ::= ID LBRACE lista_expresiones RBRACE 		{:  :}
		   	  ;			

lista_expresiones ::= lista_expresiones COMMA expresion  			{:  :}
		   	 		| expresion:e					 {: RESULT = e; :}
			 		;					  
            
/*statement ::= expr:e SEMI        			{: System.out.println(e); 							:}
            | COMMENT	                    {:  												:}
			;*/     
			  
/*factor    ::= NUMBER:n	               		{: RESULT = Double.valueOf(n);       				:}
            | DOUBLENUMBER:n	            {: RESULT = n;       								:}
            | HEXNUMBER:n	                {: RESULT = Double.valueOf(n);       				:}     
			| LPAREN expr:e RPAREN	        {: RESULT = e;           							:}
            | EXPONENTIAL expr:e1 RPAREN    {: RESULT = Math.exp(e1);        					:}         
            | LOGARITHM expr:e1 RPAREN   	{: RESULT = Math.log(e1);        					:}                  			
            | MINUS factor:e                {: RESULT = -e;           							:}           
            ; */

			
 
term ::= term:e1 TIMES operando:e2         {: RESULT = e1 * e2;        						:}
       | term:e1 DIVIDEDBY operando:e2     {: RESULT = e1 / e2;        						:}
       | operando:e					       {: RESULT = e;        							:}
	   ;            
         			         
expresion ::= expresion:e1 PLUS  term:e2         		 {: RESULT = e1 + e2;        						:}
           	| expresion:e1 MINUS term:e2         		 {: RESULT = e1 - e2;        						:}
	     	| term:e					  				 {: RESULT = e;        								:}	
			;		
			
operando_cond ::= BOOLEANVALUE:e	               		 {: RESULT = e; 				:}
			    | LPAREN expresion_cond:e RPAREN	     {: RESULT = e;           							:}       		
			    | expresion:e1 GEQUAL expresion:e2       {: RESULT = e1 >= e2;        						:}
    	        | expresion:e1 LEQUAL expresion:e2       {:   RESULT = e1 <= e2;			:}
         	    | expresion:e1 EQUALTO expresion:e2      {:    RESULT = e1 == e2;	:}
     	        | expresion:e1 LTHAN expresion:e2        {:    RESULT = e1 < e2;		:}
    	        | expresion:e1 GTHAN expresion:e2        {:    RESULT = e1 > e2;			:}
    	    	;	   
    	    	  
term_cond ::= term_cond:e1 AND operando_cond:e2         	{:     RESULT = e1 && e2;   						:}
    	    | term_cond:e1 OR operando_cond:e2        		{:    RESULT = e1 || e2;		:}         
			; 
			
expresion_cond ::= term_cond:e					    		{: RESULT = e;        								:}	
				 | NOT term_cond:e					    	{: RESULT = !e;        								:}	
			 	 ;			 		      	    	  			
       